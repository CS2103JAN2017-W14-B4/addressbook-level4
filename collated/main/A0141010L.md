# A0141010L
###### \java\seedu\ezdo\commons\core\Messages.java
``` java
    public static final String MESSAGE_WRONG_LIST = "Please return to the task list "
                                                  + "if you want to mark a task as done.";
```
###### \java\seedu\ezdo\logic\commands\DoneCommand.java
``` java
/**
 * Marks a task as identified using its last displayed index from ezDo as done
 */
public class DoneCommand extends Command implements MultipleIndexCommand {

    public static final String COMMAND_WORD = "done";
    public static final String SHORT_COMMAND_WORD = "d";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as done\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DONE_TASK_SUCCESS = "Done task: %1$s";
    public static final String MESSAGE_DONE_LISTED = "Done tasks listed";

    private final ArrayList<Integer> targetIndexes;
    private final ArrayList<Task> tasksToDone;
    private final boolean requestToViewDoneOnly;

    public DoneCommand(ArrayList<Integer> indexes) {
        this.targetIndexes = new ArrayList<Integer>(indexes);
        this.requestToViewDoneOnly = false;
        this.tasksToDone = new ArrayList<Task>();
    }

    public DoneCommand() {
        this.targetIndexes = null;
        this.requestToViewDoneOnly = true;
        this.tasksToDone = null;
    }


    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (requestToViewDoneOnly) {
            model.updateFilteredDoneList();
            return new CommandResult(MESSAGE_DONE_LISTED);
        }

        if (!isIndexValid(lastShownList)) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        if (isAnyTaskDone(lastShownList)) {
            throw new CommandException(Messages.MESSAGE_WRONG_LIST);
        }

        for (int i = 0; i < targetIndexes.size(); i++) {
            Task taskToDone = (Task) lastShownList.get(targetIndexes.get(i) - 1);
            tasksToDone.add(taskToDone);
        }

        model.doneTasks(tasksToDone);

        return new CommandResult(String.format(MESSAGE_DONE_TASK_SUCCESS, tasksToDone));
    }
```
###### \java\seedu\ezdo\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in ezDo whose name contains any of the argument
 * keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";
    public static final String SHORT_COMMAND_WORD = "f";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n" + "Example: " + COMMAND_WORD + " buy milk clean p/3";

    private final ArrayList<Object> listToCompare;
    private final boolean searchBeforeStartDate;
    private final boolean searchBeforeDueDate;
    private final boolean searchAfterStartDate;
    private final boolean searchAfterDueDate;

    public FindCommand(ArrayList<Object> listToCompare, boolean searchBeforeStartDate, boolean searchBeforeDueDate,
                       boolean searchAfterStartDate, boolean searchAfterDueDate) {
        this.listToCompare = listToCompare;
        this.searchBeforeStartDate = searchBeforeStartDate;
        this.searchBeforeDueDate = searchBeforeDueDate;
        this.searchAfterStartDate = searchAfterStartDate;
        this.searchAfterDueDate = searchAfterDueDate;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(listToCompare, searchBeforeStartDate,
                searchBeforeDueDate, searchAfterStartDate, searchAfterDueDate);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\ezdo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> startDate} into an {@code Optional<StartDate>} if {@code startDate} is present.
     */
    public static Optional<TaskDate> parseStartDate(Optional<String> startDate) throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() ? Optional.of(new StartDate(startDate.get())) : Optional.empty();
    }

    public static Optional<TaskDate> parseStartDate(Optional<String> startDate, boolean isFind)
            throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() ? Optional.of(new StartDate(startDate.get(), isFind)) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> dueDate} into an {@code Optional<DueDate>} if {@code dueDate} is present.
     */
    public static Optional<TaskDate> parseDueDate(Optional<String> dueDate) throws IllegalValueException {
        assert dueDate != null;
        return dueDate.isPresent() ? Optional.of(new DueDate(dueDate.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> dueDate} into an {@code Optional<DueDate>} if {@code dueDate} is present.
     */
    public static Optional<TaskDate> parseDueDate(Optional<String> dueDate, boolean isFind)
            throws IllegalValueException {
        assert dueDate != null;
        return dueDate.isPresent() ? Optional.of(new DueDate(dueDate.get(), isFind)) : Optional.empty();
    }
```
###### \java\seedu\ezdo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags) throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }
}
```
###### \java\seedu\ezdo\model\ModelManager.java
``` java
    @Override
    public synchronized void doneTasks(ArrayList<Task> doneTasks) {
        updateStacks();
        ezDo.doneTasks(doneTasks);
        updateFilteredListToShowAll();
        indicateEzDoChanged();
    }
```
###### \java\seedu\ezdo\model\ModelManager.java
``` java
    // =========== Filtered Task List Accessors
    // =============================================================

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredTaskList(ArrayList<Object> listToCompare, boolean startBefore,
            boolean dueBefore, boolean startAfter, boolean dueAfter) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(listToCompare,
                startBefore, dueBefore, startAfter, dueAfter)));
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskList(new PredicateExpression(new NotDoneQualifier()));
    }

    @Override
    public void updateFilteredDoneList() {
        updateFilteredTaskList(new PredicateExpression(new DoneQualifier()));
    }

    // ========== Inner classes/interfaces used for filtering
    // =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class DoneQualifier implements Qualifier {

        DoneQualifier() {

        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getDone();
        }

        @Override
        public String toString() {
            return "";
        }

    }

    private class NotDoneQualifier implements Qualifier {

        NotDoneQualifier() {

        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return !task.getDone();
        }

        @Override
        public String toString() {
            return "";
        }

    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private Optional<Priority> priority;
        private Optional<StartDate> startDate;
        private Optional<DueDate> dueDate;
        private Set<String> tags;
        private boolean startBefore;
        private boolean dueBefore;
        private boolean startAfter;
        private boolean dueAfter;

        NameQualifier(ArrayList<Object> listToCompare, boolean startBefore,
                boolean dueBefore, boolean startAfter, boolean dueAfter) {
            this.nameKeyWords = (Set<String>) listToCompare.get(0);
            this.priority = (Optional<Priority>) listToCompare.get(1);
            this.startDate = (Optional<StartDate>) listToCompare.get(2);
            this.dueDate = (Optional<DueDate>) listToCompare.get(3);
            this.tags = (Set<String>) listToCompare.get(4);
            this.startBefore = startBefore;
            this.dueBefore = dueBefore;
            this.startAfter = startAfter;
            this.dueAfter = dueAfter;

        }

        @Override
        public boolean run(ReadOnlyTask task) {

            Set<String> taskTagStringSet = convertToTagStringSet(task.getTags().toSet());

            return (nameKeyWords.contains("") || nameKeyWords.stream()
                    .allMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword)))
                    && !task.getDone()
                    && comparePriority(task.getPriority())
                    && (((!startBefore && !startAfter) && compareStartDate(task.getStartDate()))
                            || (startBefore && compareBeforeStart(task.getStartDate()))
                            || (startAfter && compareAfterStart(task.getStartDate())))
                    && (((!dueBefore && !dueAfter) && compareDueDate(task.getDueDate()))
                            || (dueBefore && compareBeforeDue(task.getDueDate()))
                            || (dueAfter && compareAfterDue(task.getDueDate())))
                    && (taskTagStringSet.containsAll(tags));

        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }

        private Set<String> convertToTagStringSet(Set<Tag> tags) {
            Object[] tagArray = tags.toArray();
            Set<String> tagSet = new HashSet<String>();

            for (int i = 0; i < tags.size(); i++) {
                tagSet.add(((Tag) tagArray[i]).tagName);
            }

            return tagSet;
        }

        private boolean comparePriority(Priority taskPriority) {

            String taskPriorityString = taskPriority.toString();
            boolean priorityExist = (taskPriorityString.length() != 0);

            return (!priority.isPresent() || (priority.get().toString().equals("") && priorityExist)
                    || (priorityExist && taskPriorityString.equals(priority.get().toString())));
        }

        private boolean compareStartDate(TaskDate taskStartDate) {

            String taskStartDateString = taskStartDate.toString();
            boolean taskStartDateExist = (taskStartDateString.length() != 0);

            return (!startDate.isPresent() || (startDate.get().toString().equals("") && taskStartDateExist)
                    || (taskStartDateExist && taskStartDateString.substring(0, 10).equals
                       (startDate.get().toString().substring(0, 10))));
        }

        private boolean compareDueDate(TaskDate taskDueDate) {

            String taskDueDateString = taskDueDate.toString();
            boolean taskDueDateExist = (taskDueDateString.length() != 0);

            return (!dueDate.isPresent() || (dueDate.get().toString().equals("") && taskDueDateExist)
                    || (taskDueDateExist && taskDueDateString.substring(0, 10).equals
                       (dueDate.get().toString().substring(0, 10))));
        }

        private boolean compareBeforeStart(TaskDate taskStartDate) {
            String taskStartDateString = taskStartDate.toString();
            boolean taskStartDateExist = (taskStartDateString.length() != 0);

            return (!startDate.isPresent() || (startDate.get().toString().equals("") && taskStartDateExist)
                    || (taskStartDateExist && comesBefore(startDate.get().toString(), taskStartDateString)));
        }

        private boolean compareBeforeDue(TaskDate taskDueDate) {
            String taskDueDateString = taskDueDate.toString();
            boolean taskDueDateExist = (taskDueDateString.length() != 0);

            return (!dueDate.isPresent() || (dueDate.get().toString().equals("") && taskDueDateExist)
                    || (taskDueDateExist && comesBefore(dueDate.get().toString(), taskDueDateString)));
        }

        private boolean compareAfterStart(TaskDate taskStartDate) {
            String taskStartDateString = taskStartDate.toString();
            boolean taskStartDateExist = (taskStartDateString.length() != 0);

            return (!startDate.isPresent() || (startDate.get().toString().equals("") && taskStartDateExist)
                    || (taskStartDateExist && comesBefore(taskStartDateString, startDate.get().toString())));
        }

        private boolean compareAfterDue(TaskDate taskDueDate) {
            String taskDueDateString = taskDueDate.toString();
            boolean taskDueDateExist = (taskDueDateString.length() != 0);

            return (!dueDate.isPresent() || (dueDate.get().toString().equals("") && taskDueDateExist)
                    || (taskDueDateExist && comesBefore(taskDueDateString, dueDate.get().toString())));
        }

        private boolean comesBefore(String givenDate, String taskDate) {

            int givenDD = Integer.parseInt(givenDate.substring(0, 2));
            int givenMM = Integer.parseInt(givenDate.substring(3, 5));
            int givenYYYY = Integer.parseInt(givenDate.substring(6, 10));

            int taskDD = Integer.parseInt(taskDate.substring(0, 2));
            int taskMM = Integer.parseInt(taskDate.substring(3, 5));
            int taskYYYY = Integer.parseInt(taskDate.substring(6, 10));

            return (taskYYYY < givenYYYY)
                   || ((taskYYYY == givenYYYY) && (taskMM < givenMM))
                   || ((taskYYYY == givenYYYY) && (taskMM == givenMM) && (taskDD <= givenDD));

        }

    }
```
###### \java\seedu\ezdo\model\todo\Priority.java
``` java
/**
 * Represents a Task's priority in the ezDo.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should only contain numbers 1-3";
    public static final String PRIORITY_VALIDATION_REGEX = "^$|[1-3]";

    public final String value;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.value = trimmedPriority;
    }

    /**
     * Returns true if a given string is a valid priority.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\ezdo\model\todo\Task.java
``` java
    public void setDone() {
        this.done = true;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setStartDate(TaskDate startDate) {
        assert startDate != null;
        this.startDate = startDate;
    }

    @Override
    public boolean getDone() {
        return this.done;
    }

    @Override
    public TaskDate getStartDate() {
        return startDate;
    }

    public void setDueDate(TaskDate dueDate) {
        assert dueDate != null;
        this.dueDate = dueDate;
    }

    @Override
    public TaskDate getDueDate() {
        return dueDate;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setStartDate(replacement.getStartDate());
        this.setDueDate(replacement.getDueDate());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, priority, startDate, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
